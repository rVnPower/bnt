{"version":3,"file":"bundle.js","sources":["../node_modules/svelte/internal/index.mjs","../node_modules/svelte/store/index.mjs","../node_modules/svelte-local-storage-store/dist/index.mjs","../src/store.js","../src/components/Title.svelte","../src/components/Clock.svelte","../src/components/Service.svelte","../node_modules/svelte-dnd-action/src/helpers/dispatcher.js","../node_modules/svelte-dnd-action/src/constants.js","../node_modules/svelte-dnd-action/src/helpers/intersection.js","../node_modules/svelte-dnd-action/src/helpers/listUtil.js","../node_modules/svelte-dnd-action/src/helpers/scroller.js","../node_modules/svelte-dnd-action/src/helpers/util.js","../node_modules/svelte-dnd-action/src/helpers/observer.js","../node_modules/svelte-dnd-action/src/helpers/windowScroller.js","../node_modules/svelte-dnd-action/src/helpers/styler.js","../node_modules/svelte-dnd-action/src/pointerAction.js","../node_modules/svelte-dnd-action/src/helpers/svelteNodeClone.js","../node_modules/svelte-dnd-action/src/helpers/aria.js","../node_modules/svelte-dnd-action/src/keyboardAction.js","../node_modules/svelte-dnd-action/src/action.js","../node_modules/svelte/easing/index.mjs","../node_modules/svelte/animate/index.mjs","../src/components/settings/Buttons.svelte","../src/components/SettingsPage.svelte","../src/App.svelte","../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            else\n                this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { stylesheet } = info;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            info.rules = {};\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape_attribute_value(value.toString())}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${style_object[key]};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.48.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        throw new Error(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","// index.ts\nimport { writable as internal, get } from \"svelte/store\";\nvar stores = {};\nfunction writable(key, initialValue) {\n  const browser = typeof localStorage != \"undefined\";\n  function updateStorage(key2, value) {\n    if (!browser)\n      return;\n    localStorage.setItem(key2, JSON.stringify(value));\n  }\n  if (!stores[key]) {\n    const store = internal(initialValue, (set2) => {\n      const json = browser ? localStorage.getItem(key) : null;\n      if (json) {\n        set2(JSON.parse(json));\n      }\n      if (browser) {\n        const handleStorage = (event) => {\n          if (event.key === key)\n            set2(event.newValue ? JSON.parse(event.newValue) : null);\n        };\n        window.addEventListener(\"storage\", handleStorage);\n        return () => window.removeEventListener(\"storage\", handleStorage);\n      }\n    });\n    const { subscribe, set } = store;\n    stores[key] = {\n      set(value) {\n        updateStorage(key, value);\n        set(value);\n      },\n      update(updater) {\n        const value = updater(get(store));\n        updateStorage(key, value);\n        set(value);\n      },\n      subscribe\n    };\n  }\n  return stores[key];\n}\nexport {\n  writable\n};\n//# sourceMappingURL=index.mjs.map\n","import { writable } from 'svelte-local-storage-store'\n\nexport const config = writable(\"config\", {\n    title: \"Hello, World!\",\n    bgPath: \"./assets/dark.png\",\n    services: [\n        {\n            name: \"Discord\",\n            url: \"#\",\n            iconUrl: \"assets/discord.png\",\n            iconW: 40,\n            iconH: 32,\n            id: 1,\n        },\n        {\n            name: \"Pixiv\",\n            url: \"https://pixiv.net\",\n            iconUrl: \"assets/pixiv.png\",\n            iconW: 40,\n            iconH: 40,\n            id: 2,\n        },\n        {\n            name: \"YouTube\",\n            url: \"https://youtube.com\",\n            iconUrl: \"assets/youtube.png\",\n            iconW: 40,\n            iconH: 27,\n            id: 3,\n        },\n        {\n            name: \"GitHub\",\n            url: \"https://github.com\",\n            iconUrl: \"assets/github.png\",\n            iconW: 40,\n            iconH: 40,\n            id: 4,\n        },\n    ]\n})\n","<script>\n    import { config } from '../store.js';\n</script>\n\n<div class=\"title\">\n    <p>{$config.title}</p>\n</div>\n\n<style>\n    .title {\n        line-break: auto;\n        line-height: 35px;\n        text-align: center;\n        width: 90%;\n    }\n\n    p {\n        font-size: 1.6em;\n    }\n\n    @media screen and (max-width: 500px) {\n        p {\n            font-size: 1.3em;\n        }\n    }\n</style>\n","<script>\n \timport { onMount } from 'svelte';\n\tlet time = new Date();\n\n\t$: hours = (time.getHours() < 10 ? \"0\" : \"\") + time.getHours();\n\t$: minutes = (time.getMinutes() < 10 ? \"0\" : \"\") + time.getMinutes();\n\t$: seconds = (time.getSeconds() < 10 ? \"0\" : \"\") + time.getSeconds();\n\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\ttime = new Date();\n\t\t}, 1000);\n\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\n<h1>{hours}:{minutes}:{seconds}</h1>\n\n<style>\n\th1 {\n\t\tfont-size: 4.5em;\n\t\ttext-shadow: 2px 1px 1px #777;\n\t}\n\n \t@media screen and (max-width: 500px) {\n\t\th1 {\n\t\t\tfont-size: 3.4em;\n\t\t}\n\t}\n</style>\n","<script>\n    export let name;\n    export let url;\n    export let iconUrl;\n    export let iconW;\n    export let iconH;\n</script>\n\n\n<a href=\"{url}\">\n    <div class=\"button\">\n        <img src=\"{iconUrl}\"\n             width=\"{iconW}\"\n             height=\"{iconH}\"/>\n        <p>{name}</p>\n    </div>\n</a>\n\n<style>\n    .button {\n        display: flex;\n        align-items: center;\n        justify-content: space-evenly;\n\n        transition: all .5s ease;\n        border-radius: 10px;\n        padding: 5px;\n\n        animation-duration: 0.2s;\n    }\n\n    .button:hover {\n        transform: translateY(-3px);\n        background: rgba(0, 0, 0, 0.4);\n    }\n\n    .button:active {\n        transform: translateY(1px);\n    }\n</style>\n","// external events\nconst FINALIZE_EVENT_NAME = \"finalize\";\nconst CONSIDER_EVENT_NAME = \"consider\";\n\n/**\n * @typedef {Object} Info\n * @property {string} trigger\n * @property {string} id\n * @property {string} source\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchFinalizeEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(FINALIZE_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n/**\n * Dispatches a consider event\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchConsiderEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(CONSIDER_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n// internal events\nexport const DRAGGED_ENTERED_EVENT_NAME = \"draggedEntered\";\nexport const DRAGGED_LEFT_EVENT_NAME = \"draggedLeft\";\nexport const DRAGGED_OVER_INDEX_EVENT_NAME = \"draggedOverIndex\";\nexport const DRAGGED_LEFT_DOCUMENT_EVENT_NAME = \"draggedLeftDocument\";\n\nexport const DRAGGED_LEFT_TYPES = {\n    LEFT_FOR_ANOTHER: \"leftForAnother\",\n    OUTSIDE_OF_ANY: \"outsideOfAny\"\n};\n\nexport function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\n\n/**\n * @param containerEl - the dropzone the element left\n * @param draggedEl - the dragged element\n * @param theOtherDz - the new dropzone the element entered\n */\nexport function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl, theOtherDz) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz}\n        })\n    );\n}\n\nexport function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY}\n        })\n    );\n}\nexport function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\nexport function dispatchDraggedLeftDocument(draggedEl) {\n    window.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {\n            detail: {draggedEl}\n        })\n    );\n}\n","import {DRAGGED_ENTERED_EVENT_NAME, DRAGGED_LEFT_EVENT_NAME, DRAGGED_OVER_INDEX_EVENT_NAME} from \"./helpers/dispatcher\";\n\nexport const TRIGGERS = {\n    DRAG_STARTED: \"dragStarted\",\n    DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_ENTERED_ANOTHER: \"dragEnteredAnother\",\n    DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,\n    DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_ALL: \"draggedLeftAll\",\n    DROPPED_INTO_ZONE: \"droppedIntoZone\",\n    DROPPED_INTO_ANOTHER: \"droppedIntoAnother\",\n    DROPPED_OUTSIDE_OF_ANY: \"droppedOutsideOfAny\",\n    DRAG_STOPPED: \"dragStopped\"\n};\n\nexport const SOURCES = {\n    POINTER: \"pointer\",\n    KEYBOARD: \"keyboard\"\n};\n\nexport const SHADOW_ITEM_MARKER_PROPERTY_NAME = \"isDndShadowItem\";\nexport const SHADOW_ELEMENT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item\";\nexport const SHADOW_PLACEHOLDER_ITEM_ID = \"id:dnd-shadow-placeholder-0000\";\nexport const DRAGGED_ELEMENT_ID = \"dnd-action-dragged-el\";\n\nexport let ITEM_ID_KEY = \"id\";\nlet activeDndZoneCount = 0;\nexport function incrementActiveDropZoneCount() {\n    activeDndZoneCount++;\n}\nexport function decrementActiveDropZoneCount() {\n    if (activeDndZoneCount === 0) {\n        throw new Error(\"Bug! trying to decrement when there are no dropzones\");\n    }\n    activeDndZoneCount--;\n}\n\n/**\n * Allows using another key instead of \"id\" in the items data. This is global and applies to all dndzones.\n * Has to be called when there are no rendered dndzones whatsoever.\n * @param {String} newKeyName\n * @throws {Error} if it was called when there are rendered dndzones or if it is given the wrong type (not a string)\n */\nexport function overrideItemIdKeyNameBeforeInitialisingDndZones(newKeyName) {\n    if (activeDndZoneCount > 0) {\n        throw new Error(\"can only override the id key before initialising any dndzone\");\n    }\n    if (typeof newKeyName !== \"string\") {\n        throw new Error(\"item id key has to be a string\");\n    }\n    printDebug(() => [\"overriding item id key name\", newKeyName]);\n    ITEM_ID_KEY = newKeyName;\n}\n\nexport const isOnServer = typeof window === \"undefined\";\n\nexport let printDebug = () => {};\n\n/**\n * Allows the user to show/hide console debug output\n * * @param {Boolean} isDebug\n */\nexport function setDebugMode(isDebug) {\n    if (isDebug) {\n        printDebug = (generateMessage, logFunction = console.debug) => {\n            const message = generateMessage();\n            if (Array.isArray(message)) {\n                logFunction(...message);\n            } else {\n                logFunction(message);\n            }\n        };\n    } else {\n        printDebug = () => {};\n    }\n}\n","// This is based off https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms/57876601#57876601\n// It removes the transforms that are potentially applied by the flip animations\n/**\n * Gets the bounding rect but removes transforms (ex: flip animation)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getBoundingRectNoTransforms(el) {\n    let ta;\n    const rect = el.getBoundingClientRect();\n    const style = getComputedStyle(el);\n    const tx = style.transform;\n\n    if (tx) {\n        let sx, sy, dx, dy;\n        if (tx.startsWith(\"matrix3d(\")) {\n            ta = tx.slice(9, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[5];\n            dx = +ta[12];\n            dy = +ta[13];\n        } else if (tx.startsWith(\"matrix(\")) {\n            ta = tx.slice(7, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[3];\n            dx = +ta[4];\n            dy = +ta[5];\n        } else {\n            return rect;\n        }\n\n        const to = style.transformOrigin;\n        const x = rect.x - dx - (1 - sx) * parseFloat(to);\n        const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(\" \") + 1));\n        const w = sx ? rect.width / sx : el.offsetWidth;\n        const h = sy ? rect.height / sy : el.offsetHeight;\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            top: y,\n            right: x + w,\n            bottom: y + h,\n            left: x\n        };\n    } else {\n        return rect;\n    }\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position and removes transforms)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRectNoTransforms(el) {\n    const rect = getBoundingRectNoTransforms(el);\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRect(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * finds the center :)\n * @typedef {Object} Rect\n * @property {number} top\n * @property {number} bottom\n * @property {number} left\n * @property {number} right\n * @param {Rect} rect\n * @return {{x: number, y: number}}\n */\nexport function findCenter(rect) {\n    return {\n        x: (rect.left + rect.right) / 2,\n        y: (rect.top + rect.bottom) / 2\n    };\n}\n\n/**\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n * @param {Point} pointA\n * @param {Point} pointB\n * @return {number}\n */\nfunction calcDistance(pointA, pointB) {\n    return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n}\n\n/**\n * @param {Point} point\n * @param {Rect} rect\n * @return {boolean|boolean}\n */\nexport function isPointInsideRect(point, rect) {\n    return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;\n}\n\n/**\n * find the absolute coordinates of the center of a dom element\n * @param el {HTMLElement}\n * @returns {{x: number, y: number}}\n */\nexport function findCenterOfElement(el) {\n    return findCenter(getAbsoluteRect(el));\n}\n\n/**\n * @param {HTMLElement} elA\n * @param {HTMLElement} elB\n * @return {boolean}\n */\nexport function isCenterOfAInsideB(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const rectOfB = getAbsoluteRectNoTransforms(elB);\n    return isPointInsideRect(centerOfA, rectOfB);\n}\n\n/**\n * @param {HTMLElement|ChildNode} elA\n * @param {HTMLElement|ChildNode} elB\n * @return {number}\n */\nexport function calcDistanceBetweenCenters(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const centerOfB = findCenterOfElement(elB);\n    return calcDistance(centerOfA, centerOfB);\n}\n\n/**\n * @param {HTMLElement} el - the element to check\n * @returns {boolean} - true if the element in its entirety is off screen including the scrollable area (the normal dom events look at the mouse rather than the element)\n */\nexport function isElementOffDocument(el) {\n    const rect = getAbsoluteRect(el);\n    return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;\n}\n\n/**\n * If the point is inside the element returns its distances from the sides, otherwise returns null\n * @param {Point} point\n * @param {HTMLElement} el\n * @return {null|{top: number, left: number, bottom: number, right: number}}\n */\nexport function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n    const rect = getAbsoluteRect(el);\n    if (!isPointInsideRect(point, rect)) {\n        return null;\n    }\n    return {\n        top: point.y - rect.top,\n        bottom: rect.bottom - point.y,\n        left: point.x - rect.left,\n        // TODO - figure out what is so special about right (why the rect is too big)\n        right: Math.min(rect.right, document.documentElement.clientWidth) - point.x\n    };\n}\n","import {isCenterOfAInsideB, calcDistanceBetweenCenters, getAbsoluteRectNoTransforms, isPointInsideRect, findCenterOfElement} from \"./intersection\";\nimport {printDebug, SHADOW_ELEMENT_ATTRIBUTE_NAME} from \"../constants\";\n\nlet dzToShadowIndexToRect;\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution. Should be called after every drag operation\n */\nexport function resetIndexesCache() {\n    printDebug(() => \"resetting indexes cache\");\n    dzToShadowIndexToRect = new Map();\n}\nresetIndexesCache();\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution for a specific dropzone, should be called after the zone was scrolled\n * @param {HTMLElement} dz\n */\nexport function resetIndexesCacheForDz(dz) {\n    printDebug(() => \"resetting indexes cache for dz\");\n    dzToShadowIndexToRect.delete(dz);\n}\n\n/**\n * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.\n * Helpful in order to determine \"would be index\" more effectively\n * @param {HTMLElement} dz\n * @return {number} - the shadow element index\n */\nfunction cacheShadowRect(dz) {\n    const shadowElIndex = Array.from(dz.children).findIndex(child => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));\n    if (shadowElIndex >= 0) {\n        if (!dzToShadowIndexToRect.has(dz)) {\n            dzToShadowIndexToRect.set(dz, new Map());\n        }\n        dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));\n        return shadowElIndex;\n    }\n    return undefined;\n}\n\n/**\n * @typedef {Object} Index\n * @property {number} index - the would be index\n * @property {boolean} isProximityBased - false if the element is actually over the index, true if it is not over it but this index is the closest\n */\n/**\n * Find the index for the dragged element in the list it is dragged over\n * @param {HTMLElement} floatingAboveEl\n * @param {HTMLElement} collectionBelowEl\n * @returns {Index|null} -  if the element is over the container the Index object otherwise null\n */\nexport function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {\n    if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {\n        return null;\n    }\n    const children = collectionBelowEl.children;\n    // the container is empty, floating element should be the first\n    if (children.length === 0) {\n        return {index: 0, isProximityBased: true};\n    }\n    const shadowElIndex = cacheShadowRect(collectionBelowEl);\n\n    // the search could be more efficient but keeping it simple for now\n    // a possible improvement: pass in the lastIndex it was found in and check there first, then expand from there\n    for (let i = 0; i < children.length; i++) {\n        if (isCenterOfAInsideB(floatingAboveEl, children[i])) {\n            const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);\n            if (cachedShadowRect) {\n                if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {\n                    return {index: shadowElIndex, isProximityBased: false};\n                }\n            }\n            return {index: i, isProximityBased: false};\n        }\n    }\n    // this can happen if there is space around the children so the floating element has\n    //entered the container but not any of the children, in this case we will find the nearest child\n    let minDistanceSoFar = Number.MAX_VALUE;\n    let indexOfMin = undefined;\n    // we are checking all of them because we don't know whether we are dealing with a horizontal or vertical container and where the floating element entered from\n    for (let i = 0; i < children.length; i++) {\n        const distance = calcDistanceBetweenCenters(floatingAboveEl, children[i]);\n        if (distance < minDistanceSoFar) {\n            minDistanceSoFar = distance;\n            indexOfMin = i;\n        }\n    }\n    return {index: indexOfMin, isProximityBased: true};\n}\n","import {calcInnerDistancesBetweenPointAndSidesOfElement} from \"./intersection\";\nconst SCROLL_ZONE_PX = 25;\n\nexport function makeScroller() {\n    let scrollingInfo;\n    function resetScrolling() {\n        scrollingInfo = {directionObj: undefined, stepPx: 0};\n    }\n    resetScrolling();\n    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x\n    function scrollContainer(containerEl) {\n        const {directionObj, stepPx} = scrollingInfo;\n        if (directionObj) {\n            containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);\n            window.requestAnimationFrame(() => scrollContainer(containerEl));\n        }\n    }\n    function calcScrollStepPx(distancePx) {\n        return SCROLL_ZONE_PX - distancePx;\n    }\n\n    /**\n     * If the pointer is next to the sides of the element to scroll, will trigger scrolling\n     * Can be called repeatedly with updated pointer and elementToScroll values without issues\n     * @return {boolean} - true if scrolling was needed\n     */\n    function scrollIfNeeded(pointer, elementToScroll) {\n        if (!elementToScroll) {\n            return false;\n        }\n        const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n        if (distances === null) {\n            resetScrolling();\n            return false;\n        }\n        const isAlreadyScrolling = !!scrollingInfo.directionObj;\n        let [scrollingVertically, scrollingHorizontally] = [false, false];\n        // vertical\n        if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n            if (distances.bottom < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: 1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);\n            } else if (distances.top < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: -1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.top);\n            }\n            if (!isAlreadyScrolling && scrollingVertically) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        // horizontal\n        if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n            if (distances.right < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: 1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.right);\n            } else if (distances.left < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: -1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.left);\n            }\n            if (!isAlreadyScrolling && scrollingHorizontally) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        resetScrolling();\n        return false;\n    }\n\n    return {\n        scrollIfNeeded,\n        resetScrolling\n    };\n}\n","/**\n * @param {Object} object\n * @return {string}\n */\nexport function toString(object) {\n    return JSON.stringify(object, null, 2);\n}\n\n/**\n * Finds the depth of the given node in the DOM tree\n * @param {HTMLElement} node\n * @return {number} - the depth of the node\n */\nexport function getDepth(node) {\n    if (!node) {\n        throw new Error(\"cannot get depth of a falsy node\");\n    }\n    return _getDepth(node, 0);\n}\nfunction _getDepth(node, countSoFar = 0) {\n    if (!node.parentElement) {\n        return countSoFar - 1;\n    }\n    return _getDepth(node.parentElement, countSoFar + 1);\n}\n\n/**\n * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in\n * @param {Object} objA\n * @param {Object} objB\n * @return {boolean} - true if objA and objB are shallow equal\n */\nexport function areObjectsShallowEqual(objA, objB) {\n    if (Object.keys(objA).length !== Object.keys(objB).length) {\n        return false;\n    }\n    for (const keyA in objA) {\n        if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Shallow compares two arrays\n * @param arrA\n * @param arrB\n * @return {boolean} - whether the arrays are shallow equal\n */\nexport function areArraysShallowEqualSameOrder(arrA, arrB) {\n    if (arrA.length !== arrB.length) {\n        return false;\n    }\n    for (let i = 0; i < arrA.length; i++) {\n        if (arrA[i] !== arrB[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import {findWouldBeIndex, resetIndexesCache, resetIndexesCacheForDz} from \"./listUtil\";\nimport {findCenterOfElement, isElementOffDocument} from \"./intersection\";\nimport {\n    dispatchDraggedElementEnteredContainer,\n    dispatchDraggedElementLeftContainerForAnother,\n    dispatchDraggedElementLeftContainerForNone,\n    dispatchDraggedLeftDocument,\n    dispatchDraggedElementIsOverIndex\n} from \"./dispatcher\";\nimport {makeScroller} from \"./scroller\";\nimport {getDepth} from \"./util\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 200;\nconst TOLERANCE_PX = 10;\nconst {scrollIfNeeded, resetScrolling} = makeScroller();\nlet next;\n\n/**\n * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)\n * @param {Set<HTMLElement>} dropZones\n * @param {HTMLElement} draggedEl\n * @param {number} [intervalMs = INTERVAL_MS]\n */\nexport function observe(draggedEl, dropZones, intervalMs = INTERVAL_MS) {\n    // initialization\n    let lastDropZoneFound;\n    let lastIndexFound;\n    let lastIsDraggedInADropZone = false;\n    let lastCentrePositionOfDragged;\n    // We are sorting to make sure that in case of nested zones of the same type the one \"on top\" is considered first\n    const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n\n    /**\n     * The main function in this module. Tracks where everything is/ should be a take the actions\n     */\n    function andNow() {\n        const currentCenterOfDragged = findCenterOfElement(draggedEl);\n        const scrolled = scrollIfNeeded(currentCenterOfDragged, lastDropZoneFound);\n        // we only want to make a new decision after the element was moved a bit to prevent flickering\n        if (\n            !scrolled &&\n            lastCentrePositionOfDragged &&\n            Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX &&\n            Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX\n        ) {\n            next = window.setTimeout(andNow, intervalMs);\n            return;\n        }\n        if (isElementOffDocument(draggedEl)) {\n            printDebug(() => \"off document\");\n            dispatchDraggedLeftDocument(draggedEl);\n            return;\n        }\n\n        lastCentrePositionOfDragged = currentCenterOfDragged;\n        // this is a simple algorithm, potential improvement: first look at lastDropZoneFound\n        let isDraggedInADropZone = false;\n        for (const dz of dropZonesFromDeepToShallow) {\n            if (scrolled) resetIndexesCacheForDz(lastDropZoneFound);\n            const indexObj = findWouldBeIndex(draggedEl, dz);\n            if (indexObj === null) {\n                // it is not inside\n                continue;\n            }\n            const {index} = indexObj;\n            isDraggedInADropZone = true;\n            // the element is over a container\n            if (dz !== lastDropZoneFound) {\n                lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);\n                dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);\n                lastDropZoneFound = dz;\n            } else if (index !== lastIndexFound) {\n                dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);\n                lastIndexFound = index;\n            }\n            // we handle looping with the 'continue' statement above\n            break;\n        }\n        // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in\n        if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {\n            dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);\n            lastDropZoneFound = undefined;\n            lastIndexFound = undefined;\n            lastIsDraggedInADropZone = false;\n        } else {\n            lastIsDraggedInADropZone = true;\n        }\n        next = window.setTimeout(andNow, intervalMs);\n    }\n    andNow();\n}\n\n// assumption - we can only observe one dragged element at a time, this could be changed in the future\nexport function unobserve() {\n    printDebug(() => \"unobserving\");\n    clearTimeout(next);\n    resetScrolling();\n    resetIndexesCache();\n}\n","import {makeScroller} from \"./scroller\";\nimport {printDebug} from \"../constants\";\nimport {resetIndexesCache} from \"./listUtil\";\n\nconst INTERVAL_MS = 300;\nlet mousePosition;\n\n/**\n * Do not use this! it is visible for testing only until we get over the issue Cypress not triggering the mousemove listeners\n * // TODO - make private (remove export)\n * @param {{clientX: number, clientY: number}} e\n */\nexport function updateMousePosition(e) {\n    const c = e.touches ? e.touches[0] : e;\n    mousePosition = {x: c.clientX, y: c.clientY};\n}\nconst {scrollIfNeeded, resetScrolling} = makeScroller();\nlet next;\n\nfunction loop() {\n    if (mousePosition) {\n        const scrolled = scrollIfNeeded(mousePosition, document.documentElement);\n        if (scrolled) resetIndexesCache();\n    }\n    next = window.setTimeout(loop, INTERVAL_MS);\n}\n\n/**\n * will start watching the mouse pointer and scroll the window if it goes next to the edges\n */\nexport function armWindowScroller() {\n    printDebug(() => \"arming window scroller\");\n    window.addEventListener(\"mousemove\", updateMousePosition);\n    window.addEventListener(\"touchmove\", updateMousePosition);\n    loop();\n}\n\n/**\n * will stop watching the mouse pointer and won't scroll the window anymore\n */\nexport function disarmWindowScroller() {\n    printDebug(() => \"disarming window scroller\");\n    window.removeEventListener(\"mousemove\", updateMousePosition);\n    window.removeEventListener(\"touchmove\", updateMousePosition);\n    mousePosition = undefined;\n    window.clearTimeout(next);\n    resetScrolling();\n}\n","import {SHADOW_ELEMENT_ATTRIBUTE_NAME, DRAGGED_ELEMENT_ID} from \"../constants\";\nimport {findCenter} from \"./intersection\";\nimport { svelteNodeClone } from \"./svelteNodeClone\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n    return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    const draggedEl = svelteNodeClone(originalElement);\n    copyStylesFromTo(originalElement, draggedEl);\n    draggedEl.id = DRAGGED_ELEMENT_ID;\n    draggedEl.style.position = \"fixed\";\n    let elTopPx = rect.top;\n    let elLeftPx = rect.left;\n    draggedEl.style.top = `${elTopPx}px`;\n    draggedEl.style.left = `${elLeftPx}px`;\n    if (positionCenterOnXY) {\n        const center = findCenter(rect);\n        elTopPx -= center.y - positionCenterOnXY.y;\n        elLeftPx -= center.x - positionCenterOnXY.x;\n        window.setTimeout(() => {\n            draggedEl.style.top = `${elTopPx}px`;\n            draggedEl.style.left = `${elLeftPx}px`;\n        }, 0);\n    }\n    draggedEl.style.margin = \"0\";\n    // we can't have relative or automatic height and width or it will break the illusion\n    draggedEl.style.boxSizing = \"border-box\";\n    draggedEl.style.height = `${rect.height}px`;\n    draggedEl.style.width = `${rect.width}px`;\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ${trs(\"background-color\")}, ${trs(\"opacity\")}, ${trs(\"color\")} `;\n    // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n    window.setTimeout(() => (draggedEl.style.transition += `, ${trs(\"width\")}, ${trs(\"height\")}`), 0);\n    draggedEl.style.zIndex = \"9999\";\n    draggedEl.style.cursor = \"grabbing\";\n\n    return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nexport function moveDraggedElementToWasDroppedState(draggedEl) {\n    draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n * @param {function} transformDraggedElement - function to transform the dragged element, does nothing by default.\n */\nexport function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY, transformDraggedElement) {\n    const newRect = copyFromEl.getBoundingClientRect();\n    const draggedElRect = draggedEl.getBoundingClientRect();\n    const widthChange = newRect.width - draggedElRect.width;\n    const heightChange = newRect.height - draggedElRect.height;\n    if (widthChange || heightChange) {\n        const relativeDistanceOfMousePointerFromDraggedSides = {\n            left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n            top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n        };\n        draggedEl.style.height = `${newRect.height}px`;\n        draggedEl.style.width = `${newRect.width}px`;\n        draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;\n        draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;\n    }\n\n    /// other properties\n    copyStylesFromTo(copyFromEl, draggedEl);\n    transformDraggedElement();\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    const computedStyle = window.getComputedStyle(copyFromEl);\n    Array.from(computedStyle)\n        .filter(\n            s =>\n                s.startsWith(\"background\") ||\n                s.startsWith(\"padding\") ||\n                s.startsWith(\"font\") ||\n                s.startsWith(\"text\") ||\n                s.startsWith(\"align\") ||\n                s.startsWith(\"justify\") ||\n                s.startsWith(\"display\") ||\n                s.startsWith(\"flex\") ||\n                s.startsWith(\"border\") ||\n                s === \"opacity\" ||\n                s === \"color\" ||\n                s === \"list-style-type\"\n        )\n        .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nexport function styleDraggable(draggableEl, dragDisabled) {\n    draggableEl.draggable = false;\n    draggableEl.ondragstart = () => false;\n    if (!dragDisabled) {\n        draggableEl.style.userSelect = \"none\";\n        draggableEl.style.WebkitUserSelect = \"none\";\n        draggableEl.style.cursor = \"grab\";\n    } else {\n        draggableEl.style.userSelect = \"\";\n        draggableEl.style.WebkitUserSelect = \"\";\n        draggableEl.style.cursor = \"\";\n    }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nexport function hideElement(dragTarget) {\n    dragTarget.style.display = \"none\";\n    dragTarget.style.position = \"fixed\";\n    dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function decorateShadowEl(shadowEl) {\n    shadowEl.style.visibility = \"hidden\";\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function unDecorateShadowElement(shadowEl) {\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        getClasses(dz).forEach(c => dz.classList.add(c));\n    });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\";\n        });\n        getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));\n    });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nexport function preventShrinking(el) {\n    const originalMinHeight = el.style.minHeight;\n    el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n    const originalMinWidth = el.style.minWidth;\n    el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n    return function undo() {\n        el.style.minHeight = originalMinHeight;\n        el.style.minWidth = originalMinWidth;\n    };\n}\n","import {\n    decrementActiveDropZoneCount,\n    incrementActiveDropZoneCount,\n    ITEM_ID_KEY,\n    printDebug,\n    SHADOW_ITEM_MARKER_PROPERTY_NAME,\n    SHADOW_PLACEHOLDER_ITEM_ID,\n    SOURCES,\n    TRIGGERS\n} from \"./constants\";\nimport {observe, unobserve} from \"./helpers/observer\";\nimport {armWindowScroller, disarmWindowScroller} from \"./helpers/windowScroller\";\nimport {\n    createDraggedElementFrom,\n    decorateShadowEl,\n    hideElement,\n    morphDraggedElementToBeLike,\n    moveDraggedElementToWasDroppedState,\n    preventShrinking,\n    styleActiveDropZones,\n    styleDraggable,\n    styleInactiveDropZones,\n    unDecorateShadowElement\n} from \"./helpers/styler\";\nimport {\n    dispatchConsiderEvent,\n    dispatchFinalizeEvent,\n    DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_LEFT_DOCUMENT_EVENT_NAME,\n    DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_TYPES,\n    DRAGGED_OVER_INDEX_EVENT_NAME\n} from \"./helpers/dispatcher\";\nimport {areArraysShallowEqualSameOrder, areObjectsShallowEqual, toString} from \"./helpers/util\";\nimport {getBoundingRectNoTransforms} from \"./helpers/intersection\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst MIN_OBSERVATION_INTERVAL_MS = 100;\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet originalDragTarget;\nlet draggedEl;\nlet draggedElData;\nlet draggedElType;\nlet originDropZone;\nlet originIndex;\nlet shadowElData;\nlet shadowElDropZone;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\nlet finalizingPreviousDrag = false;\nlet unlockOriginDzMinDimensions;\nlet isDraggedOutsideOfAnyDz = false;\nlet scheduledForRemovalAfterDrop = [];\n\n// a map from type to a set of drop-zones\nconst typeToDropZones = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nconst dzToConfig = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nconst elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n    printDebug(() => \"watching dragged element\");\n    armWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n    const observationIntervalMs = Math.max(\n        MIN_OBSERVATION_INTERVAL_MS,\n        ...Array.from(dropZones.keys()).map(dz => dzToConfig.get(dz).dropAnimationDurationMs)\n    );\n    observe(draggedEl, dropZones, observationIntervalMs * 1.07);\n}\nfunction unWatchDraggedElement() {\n    printDebug(() => \"unwatching dragged element\");\n    disarmWindowScroller();\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    unobserve();\n}\n\n// finds the initial placeholder that is placed there on drag start\nfunction findShadowPlaceHolderIdx(items) {\n    return items.findIndex(item => item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID);\n}\nfunction findShadowElementIdx(items) {\n    // checking that the id is not the placeholder's for Dragula like usecases\n    return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID);\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n    printDebug(() => [\"dragged entered\", e.currentTarget, e.detail]);\n    let {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"ignoring dragged entered because drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet\n    items = items.filter(item => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);\n    printDebug(() => `dragged entered items ${toString(items)}`);\n\n    if (originDropZone !== e.currentTarget) {\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n        dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n            trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    } else {\n        const shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);\n        if (shadowPlaceHolderIdx !== -1) {\n            // only happens right after drag start, on the first drag entered event\n            printDebug(() => \"removing placeholder item from origin dz\");\n            items.splice(shadowPlaceHolderIdx, 1);\n        }\n    }\n\n    const {index, isProximityBased} = e.detail.indexObj;\n    const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;\n    shadowElDropZone = e.currentTarget;\n    items.splice(shadowElIdx, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\nfunction handleDraggedLeft(e) {\n    // dealing with a rare race condition on extremely rapid clicking and dropping\n    if (!isWorkingOnPreviousDrag) return;\n    printDebug(() => [\"dragged left\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const shadowElIdx = findShadowElementIdx(items);\n    const shadowItem = items.splice(shadowElIdx, 1)[0];\n    shadowElDropZone = undefined;\n    const {type, theOtherDz} = e.detail;\n    if (\n        type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||\n        (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled)\n    ) {\n        printDebug(() => \"dragged left all, putting shadow element back in the origin dz\");\n        isDraggedOutsideOfAnyDz = true;\n        shadowElDropZone = originDropZone;\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        originZoneItems.splice(originIndex, 0, shadowItem);\n        dispatchConsiderEvent(originDropZone, originZoneItems, {\n            trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n    dispatchConsiderEvent(e.currentTarget, items, {\n        trigger: TRIGGERS.DRAGGED_LEFT,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n    });\n}\nfunction handleDraggedIsOverIndex(e) {\n    printDebug(() => [\"dragged is over index\", e.currentTarget, e.detail]);\n    const {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    const {index} = e.detail.indexObj;\n    const shadowElIdx = findShadowElementIdx(items);\n    items.splice(shadowElIdx, 1);\n    items.splice(index, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n    e.preventDefault();\n    const c = e.touches ? e.touches[0] : e;\n    currentMousePosition = {x: c.clientX, y: c.clientY};\n    draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${\n        currentMousePosition.y - dragStartMousePosition.y\n    }px, 0)`;\n}\n\nfunction handleDrop() {\n    printDebug(() => \"dropped\");\n    finalizingPreviousDrag = true;\n    // cleanup\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"touchmove\", handleMouseMove);\n    window.removeEventListener(\"mouseup\", handleDrop);\n    window.removeEventListener(\"touchend\", handleDrop);\n    unWatchDraggedElement();\n    moveDraggedElementToWasDroppedState(draggedEl);\n\n    if (!shadowElDropZone) {\n        printDebug(() => \"element was dropped right after it left origin but before entering somewhere else\");\n        shadowElDropZone = originDropZone;\n    }\n    printDebug(() => [\"dropped in dz\", shadowElDropZone]);\n    let {items, type} = dzToConfig.get(shadowElDropZone);\n    styleInactiveDropZones(\n        typeToDropZones.get(type),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    let shadowElIdx = findShadowElementIdx(items);\n    // the handler might remove the shadow element, ex: dragula like copy on drag\n    if (shadowElIdx === -1) shadowElIdx = originIndex;\n    items = items.map(item => (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item));\n    function finalizeWithinZone() {\n        unlockOriginDzMinDimensions();\n        dispatchFinalizeEvent(shadowElDropZone, items, {\n            trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n        if (shadowElDropZone !== originDropZone) {\n            // letting the origin drop zone know the element was permanently taken away\n            dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {\n                trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n                id: draggedElData[ITEM_ID_KEY],\n                source: SOURCES.POINTER\n            });\n        }\n        unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);\n        cleanupPostDrop();\n    }\n    animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n    const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);\n    const newTransform = {\n        x: shadowElRect.left - parseFloat(draggedEl.style.left),\n        y: shadowElRect.top - parseFloat(draggedEl.style.top)\n    };\n    const {dropAnimationDurationMs} = dzToConfig.get(shadowElDropZone);\n    const transition = `transform ${dropAnimationDurationMs}ms ease`;\n    draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n    draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;\n    window.setTimeout(callback, dropAnimationDurationMs);\n}\n\nfunction scheduleDZForRemovalAfterDrop(dz, destroy) {\n    scheduledForRemovalAfterDrop.push({dz, destroy});\n    window.requestAnimationFrame(() => {\n        hideElement(dz);\n        document.body.appendChild(dz);\n    });\n}\n/* cleanup */\nfunction cleanupPostDrop() {\n    draggedEl.remove();\n    originalDragTarget.remove();\n    if (scheduledForRemovalAfterDrop.length) {\n        printDebug(() => [\"will destroy zones that were removed during drag\", scheduledForRemovalAfterDrop]);\n        scheduledForRemovalAfterDrop.forEach(({dz, destroy}) => {\n            destroy();\n            dz.remove();\n        })\n        scheduledForRemovalAfterDrop = [];\n    }\n    draggedEl = undefined;\n    originalDragTarget = undefined;\n    draggedElData = undefined;\n    draggedElType = undefined;\n    originDropZone = undefined;\n    originIndex = undefined;\n    shadowElData = undefined;\n    shadowElDropZone = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n    isWorkingOnPreviousDrag = false;\n    finalizingPreviousDrag = false;\n    unlockOriginDzMinDimensions = undefined;\n    isDraggedOutsideOfAnyDz = false;\n}\n\nexport function dndzone(node, options) {\n    let initialized = false;\n    const config = {\n        items: undefined,\n        type: undefined,\n        flipDurationMs: 0,\n        dragDisabled: false,\n        morphDisabled: false,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        transformDraggedElement: () => {},\n        centreDraggedOnCursor: false\n    };\n    printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, {node}]);\n    let elToIdx = new Map();\n\n    function addMaybeListeners() {\n        window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleFalseAlarm, {passive: false});\n        window.addEventListener(\"touchend\", handleFalseAlarm, {passive: false});\n    }\n    function removeMaybeListeners() {\n        window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"mouseup\", handleFalseAlarm);\n        window.removeEventListener(\"touchend\", handleFalseAlarm);\n    }\n    function handleFalseAlarm() {\n        removeMaybeListeners();\n        originalDragTarget = undefined;\n        dragStartMousePosition = undefined;\n        currentMousePosition = undefined;\n    }\n\n    function handleMouseMoveMaybeDragStart(e) {\n        e.preventDefault();\n        const c = e.touches ? e.touches[0] : e;\n        currentMousePosition = {x: c.clientX, y: c.clientY};\n        if (\n            Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n            Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n        ) {\n            removeMaybeListeners();\n            handleDragStart();\n        }\n    }\n    function handleMouseDown(e) {\n        // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n        if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n            printDebug(() => \"won't initiate drag on a nested input element\");\n            return;\n        }\n        // prevents responding to any button but left click which equals 0 (which is falsy)\n        if (e.button) {\n            printDebug(() => `ignoring none left click button: ${e.button}`);\n            return;\n        }\n        if (isWorkingOnPreviousDrag) {\n            printDebug(() => \"cannot start a new drag before finalizing previous one\");\n            return;\n        }\n        e.stopPropagation();\n        const c = e.touches ? e.touches[0] : e;\n        dragStartMousePosition = {x: c.clientX, y: c.clientY};\n        currentMousePosition = {...dragStartMousePosition};\n        originalDragTarget = e.currentTarget;\n        addMaybeListeners();\n    }\n\n    function handleDragStart() {\n        printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);\n        isWorkingOnPreviousDrag = true;\n\n        // initialising globals\n        const currentIdx = elToIdx.get(originalDragTarget);\n        originIndex = currentIdx;\n        originDropZone = originalDragTarget.parentElement;\n        /** @type {ShadowRoot | HTMLDocument} */\n        const rootNode = originDropZone.getRootNode();\n        const originDropZoneRoot = rootNode.body || rootNode;\n        const {items, type, centreDraggedOnCursor} = config;\n        draggedElData = {...items[currentIdx]};\n        draggedElType = type;\n        shadowElData = {...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true};\n        // The initial shadow element. We need a different id at first in order to avoid conflicts and timing issues\n        const placeHolderElData = {...shadowElData, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID};\n\n        // creating the draggable element\n        draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n        // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n        function keepOriginalElementInDom() {\n            if (!draggedEl.parentElement) {\n                originDropZoneRoot.appendChild(draggedEl);\n                // to prevent the outline from disappearing\n                draggedEl.focus();\n                watchDraggedElement();\n                hideElement(originalDragTarget);\n                originDropZoneRoot.appendChild(originalDragTarget);\n            } else {\n                window.requestAnimationFrame(keepOriginalElementInDom);\n            }\n        }\n        window.requestAnimationFrame(keepOriginalElementInDom);\n\n        styleActiveDropZones(\n            Array.from(typeToDropZones.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n\n        // removing the original element by removing its data entry\n        items.splice(currentIdx, 1, placeHolderElData);\n        unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n\n        dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n\n        // handing over to global handlers - starting to watch the element\n        window.addEventListener(\"mousemove\", handleMouseMove, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMove, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleDrop, {passive: false});\n        window.addEventListener(\"touchend\", handleDrop, {passive: false});\n    }\n\n    function configure({\n        items = undefined,\n        flipDurationMs: dropAnimationDurationMs = 0,\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        morphDisabled = false,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        transformDraggedElement = () => {},\n        centreDraggedOnCursor = false\n    }) {\n        config.dropAnimationDurationMs = dropAnimationDurationMs;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.morphDisabled = morphDisabled;\n        config.transformDraggedElement = transformDraggedElement;\n        config.centreDraggedOnCursor = centreDraggedOnCursor;\n\n        // realtime update for dropTargetStyle\n        if (\n            initialized &&\n            isWorkingOnPreviousDrag &&\n            !finalizingPreviousDrag &&\n            (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||\n                !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))\n        ) {\n            styleInactiveDropZones(\n                [node],\n                () => config.dropTargetStyle,\n                () => dropTargetClasses\n            );\n            styleActiveDropZones(\n                [node],\n                () => dropTargetStyle,\n                () => dropTargetClasses\n            );\n        }\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = [...dropTargetClasses];\n\n        // realtime update for dropFromOthersDisabled\n        function getConfigProp(dz, propName) {\n            return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];\n        }\n        if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n            if (dropFromOthersDisabled) {\n                styleInactiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            } else {\n                styleActiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            }\n        }\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n\n        dzToConfig.set(node, config);\n        const shadowElIdx = findShadowElementIdx(config.items);\n        for (let idx = 0; idx < node.children.length; idx++) {\n            const draggableEl = node.children[idx];\n            styleDraggable(draggableEl, dragDisabled);\n            if (idx === shadowElIdx) {\n                if (!morphDisabled) {\n                    morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y, () =>\n                        config.transformDraggedElement(draggedEl, draggedElData, idx)\n                    );\n                }\n                decorateShadowEl(draggableEl);\n                continue;\n            }\n            draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n            draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n                draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n                elToMouseDownListener.set(draggableEl, handleMouseDown);\n            }\n            // updating the idx\n            elToIdx.set(draggableEl, idx);\n\n            if (!initialized) {\n                initialized = true;\n            }\n        }\n    }\n    configure(options);\n\n    return {\n        update: newOptions => {\n            printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            function destroyDz() {\n                printDebug(() => \"pointer dndzone will destroy\");\n                unregisterDropZone(node, dzToConfig.get(node).type);\n                dzToConfig.delete(node);\n            }\n            if (isWorkingOnPreviousDrag) {\n                printDebug(() => \"pointer dndzone will be scheduled for destruction\");\n                scheduleDZForRemovalAfterDrop(node, destroyDz);\n            } else {\n               destroyDz();\n            }\n        }\n    };\n}\n","/**\n * Fixes svelte issue when cloning node containing (or being) <select> which will loose it's value.\n * Since svelte manages select value internally.\n * @see https://github.com/sveltejs/svelte/issues/6717\n * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306\n * \n * @param {HTMLElement} el \n * @returns \n */\nexport function svelteNodeClone(el) {\n  const cloned = el.cloneNode(true);\n\n  const values = [];\n  const elIsSelect = el.tagName === \"SELECT\";\n  const selects = elIsSelect ? [el] : [...el.querySelectorAll('select')];\n  for (const select of selects) {\n    values.push(select.value);\n  }\n\n  if (selects.length <= 0) {\n    return cloned;\n  }\n\n  const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll('select')];\n  for (let i = 0; i < clonedSelects.length; i++) {\n    const select = clonedSelects[i];\n    const value = values[i];\n    const optionEl = select.querySelector(`option[value=\"${value}\"`);\n    if (optionEl) {\n      optionEl.setAttribute('selected', true);\n    }\n  }\n\n  return cloned;\n}\n","import {isOnServer} from \"../constants\";\n\nconst INSTRUCTION_IDs = {\n    DND_ZONE_ACTIVE: \"dnd-zone-active\",\n    DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nconst ID_TO_INSTRUCTION = {\n    [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: \"Tab to one the items and press space-bar or enter to start dragging it\",\n    [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: \"This is a disabled drag and drop list\"\n};\n\nconst ALERT_DIV_ID = \"dnd-action-aria-alert\";\nlet alertsDiv;\n\nfunction initAriaOnBrowser() {\n    if (alertsDiv) {\n        // it is already initialized\n        return;\n    }\n    // setting the dynamic alerts\n    alertsDiv = document.createElement(\"div\");\n    (function initAlertsDiv() {\n        alertsDiv.id = ALERT_DIV_ID;\n        // tab index -1 makes the alert be read twice on chrome for some reason\n        //alertsDiv.tabIndex = -1;\n        alertsDiv.style.position = \"fixed\";\n        alertsDiv.style.bottom = \"0\";\n        alertsDiv.style.left = \"0\";\n        alertsDiv.style.zIndex = \"-5\";\n        alertsDiv.style.opacity = \"0\";\n        alertsDiv.style.height = \"0\";\n        alertsDiv.style.width = \"0\";\n        alertsDiv.setAttribute(\"role\", \"alert\");\n    })();\n    document.body.prepend(alertsDiv);\n\n    // setting the instructions\n    Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nexport function initAria() {\n    if (isOnServer) return null;\n    if (document.readyState === \"complete\") {\n        initAriaOnBrowser();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n    }\n    return {...INSTRUCTION_IDs};\n}\n\n/**\n * Removes all the artifacts (dom elements) added by this module\n */\nexport function destroyAria() {\n    if (isOnServer || !alertsDiv) return;\n    Object.keys(ID_TO_INSTRUCTION).forEach(id => document.getElementById(id)?.remove());\n    alertsDiv.remove();\n    alertsDiv = undefined;\n}\n\nfunction instructionToHiddenDiv(id, txt) {\n    const div = document.createElement(\"div\");\n    div.id = id;\n    div.innerHTML = `<p>${txt}</p>`;\n    div.style.display = \"none\";\n    div.style.position = \"fixed\";\n    div.style.zIndex = \"-5\";\n    return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return;\n    if (!alertsDiv) {\n        initAriaOnBrowser();\n    }\n    alertsDiv.innerHTML = \"\";\n    const alertText = document.createTextNode(txt);\n    alertsDiv.appendChild(alertText);\n    // this is needed for Safari\n    alertsDiv.style.display = \"none\";\n    alertsDiv.style.display = \"inline\";\n}\n","import {decrementActiveDropZoneCount, incrementActiveDropZoneCount, ITEM_ID_KEY, SOURCES, TRIGGERS} from \"./constants\";\nimport {styleActiveDropZones, styleInactiveDropZones} from \"./helpers/styler\";\nimport {dispatchConsiderEvent, dispatchFinalizeEvent} from \"./helpers/dispatcher\";\nimport {initAria, alertToScreenReader, destroyAria} from \"./helpers/aria\";\nimport {toString} from \"./helpers/util\";\nimport {printDebug} from \"./constants\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet isDragging = false;\nlet draggedItemType;\nlet focusedDz;\nlet focusedDzLabel = \"\";\nlet focusedItem;\nlet focusedItemId;\nlet focusedItemLabel = \"\";\nconst allDragTargets = new WeakSet();\nconst elToKeyDownListeners = new WeakMap();\nconst elToFocusListeners = new WeakMap();\nconst dzToHandles = new Map();\nconst dzToConfig = new Map();\nconst typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nlet INSTRUCTION_IDs;\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"adding global keydown and click handlers\");\n        INSTRUCTION_IDs = initAria();\n        window.addEventListener(\"keydown\", globalKeyDownHandler);\n        window.addEventListener(\"click\", globalClickHandler);\n    }\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    printDebug(() => \"unregistering drop-zone\");\n    if (focusedDz === dropZoneEl) {\n        handleDrop();\n    }\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"removing global keydown and click handlers\");\n        window.removeEventListener(\"keydown\", globalKeyDownHandler);\n        window.removeEventListener(\"click\", globalClickHandler);\n        INSTRUCTION_IDs = undefined;\n        destroyAria();\n    }\n}\n\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    switch (e.key) {\n        case \"Escape\": {\n            handleDrop();\n            break;\n        }\n    }\n}\n\nfunction globalClickHandler() {\n    if (!isDragging) return;\n    if (!allDragTargets.has(document.activeElement)) {\n        printDebug(() => \"clicked outside of any draggable\");\n        handleDrop();\n    }\n}\n\nfunction handleZoneFocus(e) {\n    printDebug(() => \"zone focus\");\n    if (!isDragging) return;\n    const newlyFocusedDz = e.currentTarget;\n    if (newlyFocusedDz === focusedDz) return;\n\n    focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n    const {items: originItems} = dzToConfig.get(focusedDz);\n    const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);\n    const originIdx = originItems.indexOf(originItem);\n    const itemToMove = originItems.splice(originIdx, 1)[0];\n    const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);\n    if (\n        newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||\n        newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left\n    ) {\n        targetItems.push(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);\n        }\n    } else {\n        targetItems.unshift(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);\n        }\n    }\n    const dzFrom = focusedDz;\n    dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});\n    dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n    focusedDz = newlyFocusedDz;\n}\n\nfunction triggerAllDzsUpdate() {\n    dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n            trigger: TRIGGERS.DRAG_STOPPED,\n            id: focusedItemId,\n            source: SOURCES.KEYBOARD\n        });\n    }\n    styleInactiveDropZones(\n        typeToDropZones.get(draggedItemType),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    draggedItemType = null;\n    focusedDz = null;\n    focusedDzLabel = \"\";\n    isDragging = false;\n    triggerAllDzsUpdate();\n}\n//////\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        dragDisabled: false,\n        zoneTabIndex: 0,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        autoAriaDisabled: false\n    };\n\n    function swap(arr, i, j) {\n        if (arr.length <= 1) return;\n        arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n    }\n\n    function handleKeyDown(e) {\n        printDebug(() => [\"handling key down\", e.key]);\n        switch (e.key) {\n            case \"Enter\":\n            case \" \": {\n                // we don't want to affect nested input elements or clickable elements\n                if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n                    return;\n                }\n                e.preventDefault(); // preventing scrolling on spacebar\n                e.stopPropagation();\n                if (isDragging) {\n                    // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n                    handleDrop();\n                } else {\n                    // drag start\n                    handleDragStart(e);\n                }\n                break;\n            }\n            case \"ArrowDown\":\n            case \"ArrowRight\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow down\", idx]);\n                if (idx < children.length - 1) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx + 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowLeft\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow up\", idx]);\n                if (idx > 0) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx - 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n        }\n    }\n    function handleDragStart(e) {\n        printDebug(() => \"drag start\");\n        setCurrentFocusedItem(e.currentTarget);\n        focusedDz = node;\n        draggedItemType = config.type;\n        isDragging = true;\n        const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);\n        styleActiveDropZones(\n            dropTargets,\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n        if (!config.autoAriaDisabled) {\n            let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;\n            if (dropTargets.length > 1) {\n                msg += `, or tab to another list in order to move the item into it`;\n            }\n            alertToScreenReader(msg);\n        }\n        dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n        triggerAllDzsUpdate();\n    }\n\n    function handleClick(e) {\n        if (!isDragging) return;\n        if (e.currentTarget === focusedItem) return;\n        e.stopPropagation();\n        handleDrop(false);\n        handleDragStart(e);\n    }\n    function setCurrentFocusedItem(draggableEl) {\n        const {items} = dzToConfig.get(node);\n        const children = Array.from(node.children);\n        const focusedItemIdx = children.indexOf(draggableEl);\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = 0;\n        focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n        focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n    }\n\n    function configure({\n        items = [],\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        zoneTabIndex = 0,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        autoAriaDisabled = false\n    }) {\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n        config.zoneTabIndex = zoneTabIndex;\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = dropTargetClasses;\n        config.autoAriaDisabled = autoAriaDisabled;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        if (!autoAriaDisabled) {\n            node.setAttribute(\"aria-disabled\", dragDisabled);\n            node.setAttribute(\"role\", \"list\");\n            node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n        }\n        dzToConfig.set(node, config);\n\n        if (isDragging) {\n            node.tabIndex =\n                node === focusedDz ||\n                focusedItem.contains(node) ||\n                config.dropFromOthersDisabled ||\n                (focusedDz && config.type !== dzToConfig.get(focusedDz).type)\n                    ? -1\n                    : 0;\n        } else {\n            node.tabIndex = config.zoneTabIndex;\n        }\n\n        node.addEventListener(\"focus\", handleZoneFocus);\n\n        for (let i = 0; i < node.children.length; i++) {\n            const draggableEl = node.children[i];\n            allDragTargets.add(draggableEl);\n            draggableEl.tabIndex = isDragging ? -1 : 0;\n            if (!autoAriaDisabled) {\n                draggableEl.setAttribute(\"role\", \"listitem\");\n            }\n            draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n            draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"keydown\", handleKeyDown);\n                elToKeyDownListeners.set(draggableEl, handleKeyDown);\n                draggableEl.addEventListener(\"click\", handleClick);\n                elToFocusListeners.set(draggableEl, handleClick);\n            }\n            if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n                printDebug(() => [\"focusing on\", {i, focusedItemId}]);\n                // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n                focusedItem = draggableEl;\n                focusedItem.tabIndex = 0;\n                // without this the element loses focus if it moves backwards in the list\n                draggableEl.focus();\n            }\n        }\n    }\n    configure(options);\n\n    const handles = {\n        update: newOptions => {\n            printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"keyboard dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n            dzToHandles.delete(node);\n        }\n    };\n    dzToHandles.set(node, handles);\n    return handles;\n}\n","import {dndzone as pointerDndZone} from \"./pointerAction\";\nimport {dndzone as keyboardDndZone} from \"./keyboardAction\";\nimport {ITEM_ID_KEY} from \"./constants\";\nimport {toString} from \"./helpers/util\";\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nexport function dndzone(node, options) {\n    validateOptions(options);\n    const pointerZone = pointerDndZone(node, options);\n    const keyboardZone = keyboardDndZone(node, options);\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\nfunction validateOptions(options) {\n    /*eslint-disable*/\n    const {\n        items,\n        flipDurationMs,\n        type,\n        dragDisabled,\n        morphDisabled,\n        dropFromOthersDisabled,\n        zoneTabIndex,\n        dropTargetStyle,\n        dropTargetClasses,\n        transformDraggedElement,\n        autoAriaDisabled,\n        centreDraggedOnCursor,\n        ...rest\n    } = options;\n    /*eslint-enable*/\n    if (Object.keys(rest).length > 0) {\n        console.warn(`dndzone will ignore unknown options`, rest);\n    }\n    if (!items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);\n    }\n    if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n        throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);\n    }\n    if (zoneTabIndex && !isInt(zoneTabIndex)) {\n        throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);\n    }\n}\n\nfunction isInt(value) {\n    return !isNaN(value) && (function(x) { return (x | 0) === x; })(parseFloat(value));\n}\n","export { identity as linear } from '../internal/index.mjs';\n\n/*\nAdapted from https://github.com/mattdesl\nDistributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md\n*/\nfunction backInOut(t) {\n    const s = 1.70158 * 1.525;\n    if ((t *= 2) < 1)\n        return 0.5 * (t * t * ((s + 1) * t - s));\n    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);\n}\nfunction backIn(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n}\nfunction backOut(t) {\n    const s = 1.70158;\n    return --t * t * ((s + 1) * t + s) + 1;\n}\nfunction bounceOut(t) {\n    const a = 4.0 / 11.0;\n    const b = 8.0 / 11.0;\n    const c = 9.0 / 10.0;\n    const ca = 4356.0 / 361.0;\n    const cb = 35442.0 / 1805.0;\n    const cc = 16061.0 / 1805.0;\n    const t2 = t * t;\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\nfunction bounceInOut(t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\nfunction bounceIn(t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\nfunction circInOut(t) {\n    if ((t *= 2) < 1)\n        return -0.5 * (Math.sqrt(1 - t * t) - 1);\n    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n}\nfunction circIn(t) {\n    return 1.0 - Math.sqrt(1.0 - t * t);\n}\nfunction circOut(t) {\n    return Math.sqrt(1 - --t * t);\n}\nfunction cubicInOut(t) {\n    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\nfunction cubicIn(t) {\n    return t * t * t;\n}\nfunction cubicOut(t) {\n    const f = t - 1.0;\n    return f * f * f + 1.0;\n}\nfunction elasticInOut(t) {\n    return t < 0.5\n        ? 0.5 *\n            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *\n            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))\n        : 0.5 *\n            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *\n            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +\n            1.0;\n}\nfunction elasticIn(t) {\n    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction elasticOut(t) {\n    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);\n}\nfunction expoInOut(t) {\n    return t === 0.0 || t === 1.0\n        ? t\n        : t < 0.5\n            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)\n            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;\n}\nfunction expoIn(t) {\n    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));\n}\nfunction expoOut(t) {\n    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);\n}\nfunction quadInOut(t) {\n    t /= 0.5;\n    if (t < 1)\n        return 0.5 * t * t;\n    t--;\n    return -0.5 * (t * (t - 2) - 1);\n}\nfunction quadIn(t) {\n    return t * t;\n}\nfunction quadOut(t) {\n    return -t * (t - 2.0);\n}\nfunction quartInOut(t) {\n    return t < 0.5\n        ? +8.0 * Math.pow(t, 4.0)\n        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;\n}\nfunction quartIn(t) {\n    return Math.pow(t, 4.0);\n}\nfunction quartOut(t) {\n    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\nfunction quintInOut(t) {\n    if ((t *= 2) < 1)\n        return 0.5 * t * t * t * t * t;\n    return 0.5 * ((t -= 2) * t * t * t * t + 2);\n}\nfunction quintIn(t) {\n    return t * t * t * t * t;\n}\nfunction quintOut(t) {\n    return --t * t * t * t * t + 1;\n}\nfunction sineInOut(t) {\n    return -0.5 * (Math.cos(Math.PI * t) - 1);\n}\nfunction sineIn(t) {\n    const v = Math.cos(t * Math.PI * 0.5);\n    if (Math.abs(v) < 1e-14)\n        return 1;\n    else\n        return 1 - v;\n}\nfunction sineOut(t) {\n    return Math.sin((t * Math.PI) / 2);\n}\n\nexport { backIn, backInOut, backOut, bounceIn, bounceInOut, bounceOut, circIn, circInOut, circOut, cubicIn, cubicInOut, cubicOut, elasticIn, elasticInOut, elasticOut, expoIn, expoInOut, expoOut, quadIn, quadInOut, quadOut, quartIn, quartInOut, quartOut, quintIn, quintInOut, quintOut, sineIn, sineInOut, sineOut };\n","import { cubicOut } from '../easing/index.mjs';\nimport { is_function } from '../internal/index.mjs';\n\nfunction flip(node, { from, to }, params = {}) {\n    const style = getComputedStyle(node);\n    const transform = style.transform === 'none' ? '' : style.transform;\n    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);\n    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);\n    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);\n    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;\n    return {\n        delay,\n        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,\n        easing,\n        css: (t, u) => {\n            const x = u * dx;\n            const y = u * dy;\n            const sx = t + u * from.width / to.width;\n            const sy = t + u * from.height / to.height;\n            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;\n        }\n    };\n}\n\nexport { flip };\n","<script>\n\timport {dndzone} from 'svelte-dnd-action';\n\timport {flip} from 'svelte/animate';\n\tconst flipDurationMs = 150;\n\texport let items;\n\texport let onDrop;\n\n\tfunction handleConsider(e) {\n\t\titems = e.detail.items;\n\t}\n\tfunction handleFinalize(e) {\n\t\tconst {items:newItems} = e.detail;\n\t\tonDrop(newItems);\n\t}\n    // This is the JS way to style the dragged element, notice it is being passed into the dnd-zone\n    function transformDraggedElement(draggedEl, data, index) {\n        draggedEl.querySelector(\".card\").style.transform = \"rotate(10deg)\";\n    }\n</script>\n\n<section use:dndzone={{items, flipDurationMs, transformDraggedElement}} on:consider={handleConsider} on:finalize={handleFinalize}>\n    {#each items as item(item.id)}\n        <div animate:flip={{duration:flipDurationMs}}>\n            <div class=\"card\">\n                {item.name}\n            </div>\n        </div>\n    {/each}\n</section>\n\n<style>\n    section {\n        width: 50%;\n        display: flex;\n        flex-direction: column;\n        gap: 8px;\n\n        background: rgba(0, 0, 0, 0.40);\n        border-radius: 10px;\n        border: 1px solid #333;\n        padding: 0.5rem 0.75rem;\n\n        transition: all .3s linear;\n    }\n\n    section:focus {\n        outline: none;\n    }\n\n    section:hover {\n        border: 1px solid #aaa;\n    }\n\n    .card {\n        background: rgba(0, 0, 0, 0.50);\n\n        display: flex;\n        align-items: center;\n\n        width: 90%;\n        padding: 10px;\n\n        border: 2px solid #222;\n        border-radius: 8px;\n    }\n\n    .card:hover {\n        border-color: #333;\n        transform: translateY(-1px);\n    }\n</style>\n","<script>\n    import { config } from \"../store.js\";\n    import Buttons from \"./settings/Buttons.svelte\";\n\n    let configTemp = $config;\n\n    // If `variable` is blank, then we return the `initial` value\n    function checkBlank(variable, initial) {\n        if (variable === \"\") {\n            return initial;\n        }\n        return variable;\n    }\n\n    // Update buttons list when dragged\n    function handleDrop(newItems) {\n        $config.services = newItems;\n    }\n</script>\n\n\n<h2>Settings</h2>\n<div class=\"settings\">\n    <!-- Title -->\n    <h3>Title</h3>\n    <input bind:value={configTemp.title}>\n    <span class=\"confirm button\"\n          on:click={() =>\n            {\n                $config.title = configTemp.title;\n            }\n    }>\n        OK\n    </span>\n    <hr/>\n    <!-- Background -->\n    <h3>Background image</h3>\n    <small><a href=\"https://github.com/rvnpower/bnt/README.md#bg\">Read about this</a></small>\n    <input bind:value={configTemp.bgPath}/>\n    <span class=\"confirm button\"\n          on:click={() =>\n            {\n                $config.bgPath = checkBlank(configTemp.bgPath, \"./assets/dark.png\");\n            }\n    }>\n        OK\n    </span>\n    <!-- Buttons -->\n    <h3>Buttons</h3>\n    <Buttons items=\"{$config.services}\" onDrop={handleDrop}/>\n</div>\n\n<style>\n    .settings {\n        display: box;\n        text-align: left;\n        width: 80%;\n        padding-bottom: 20px;\n    }\n\n    .confirm {\n        width: 15%;\n        cursor: pointer;\n        display: flex;\n        align-items: center;\n        justify-content: space-evenly;\n\n        border-radius: 10px;\n        padding: 5px;\n        margin: 5px;\n\n        background: rgba(0, 0, 0, 0.4);\n        animation-duration: 0.2s;\n    }\n\n    .confirm:active {\n        transform: translateY(1px);\n    }\n</style>\n","<script>\n    import Title from \"./components/Title.svelte\";\n    import Clock from \"./components/Clock.svelte\";\n    import Service from \"./components/Service.svelte\";\n    import SettingsPage from \"./components/SettingsPage.svelte\";\n\n    import { config } from \"./store.js\";\n\n    let settingsMode = false;\n</script>\n\n<div class=\"container flex-center\"\n     style:--bgPath=\"url({$config.bgPath})\">\n    <!-- Bind the background path into --bgPath -->\n    <div class=\"interface\">\n        <!-- The settings block (it will stay forever) -->\n        <div class=\"settings\">\n            <button class=\"settingsBtn\" on:click={() => settingsMode = !settingsMode}>\n                <img src=\"assets/gear.png\" alt=\"Settings\" width=\"40\" height=\"40\"/>\n            </button>\n        </div>\n        <!-- End settings block -->\n        {#if !settingsMode}\n            <div class=\"header flex-center\">\n                <Title/>\n                <Clock/>\n            </div>\n            <div class=\"services\">\n                {#each $config.services as service}\n                    <Service {...service}/>\n                {/each}\n            </div>\n        {:else}\n            <SettingsPage/>\n        {/if}\n    </div>\n</div>\n\n<style>\n    .container {\n        width: 100%;\n        height: auto;\n        min-height: 100vh;\n\n        background-image: var(--bgPath);\n        background-repeat: no-repeat;\n        background-size: cover;\n        background-position: center;\n        background-attachment: fixed;\n\n        font-size: 20px;\n    }\n\n    .settings {\n        height: 90px;\n        width: 95%;\n\n        display: flex;\n        align-items: center;\n        justify-content: end;\n    }\n\n    .settingsBtn {\n        background: transparent;\n        border: none;\n        cursor: pointer;\n    }\n\n    .interface {\n        display: flex;\n        align-items: center;\n        flex-direction: column;\n\n        line-height: 20px;\n\n        backdrop-filter: blur(5px);\n        background: rgba(0, 0, 0, 0.32);\n        box-shadow: 0px 10px 90px rgba(0, 0, 0, 1);\n\n        width: 45%;\n\n        border-radius: 30px;\n    }\n\n    .header {\n        flex-direction: column;\n    }\n\n    .services {\n        display: grid;\n        grid-template-columns: 0.9fr 0.9fr 0.9fr;\n        grid-template-rows: auto;\n\n        width: 100%;\n        column-gap: 10px;\n        row-gap: 10px;\n        padding: 20px;\n    }\n\n\n    @media screen and (max-width: 1000px) {\n        .services {\n            grid-template-columns: 1fr 1fr;\n            width: 90%;\n        }\n\n        .container {\n            font-size: 18px;\n        }\n\n        .interface {\n            width: 80%;\n        }\n    }\n\n    /* mobile */\n    @media screen and (max-width: 500px) {\n        .services {\n            grid-template-columns: 1fr;\n            width: 95%;\n        }\n\n        .interface {\n            height: 90%;\n            width: 90vw;\n\n            border-radius: 30px;\n        }\n\n        .container {\n            padding: 20px; /* avoid touching the screen */\n            height: auto;\n        }\n    }\n</style>\n","import App from './App.svelte';\n\n\nconst app = new App({\n\ttarget: document.body,\n});\n\nexport default app;\n"],"names":["noop","identity","x","assign","tar","src","k","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","src_url_equal_anchor","src_url_equal","element_src","url","document","createElement","href","subscribe","store","callbacks","unsub","unsubscribe","get_store_value","value","_","component_subscribe","component","callback","$$","on_destroy","push","set_store_value","ret","set","is_client","window","now","performance","Date","raf","cb","requestAnimationFrame","tasks","Set","run_tasks","task","c","delete","f","size","append","target","node","appendChild","get_root_for_style","root","getRootNode","ownerDocument","host","append_empty_stylesheet","style_element","element","style","head","append_stylesheet","sheet","insert","anchor","insertBefore","detach","parentNode","removeChild","name","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","set_data","wholeText","set_input_value","input","set_style","key","important","removeProperty","setProperty","managed_styles","Map","current_component","active","create_rule","duration","delay","ease","uid","step","keyframes","p","t","rule","str","hash","i","length","charCodeAt","doc","stylesheet","rules","get","info","create_style_information","insertRule","cssRules","animation","delete_rule","previous","split","next","filter","anim","indexOf","deleted","join","deleteRule","clear","create_animation","from","params","to","getBoundingClientRect","left","right","top","bottom","easing","start","start_time","end","tick","css","running","started","stop","Promise","fulfill","add","loop","fix_position","getComputedStyle","position","width","height","transform","add_transform","set_current_component","onMount","Error","get_current_component","on_mount","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","resolve","update_scheduled","add_render_callback","seen_callbacks","flushidx","flush","saved_component","update","pop","has","fragment","before_update","dirty","ctx","after_update","outroing","outros","group_outros","r","check_outros","transition_in","block","local","transition_out","o","d","fix_and_destroy_block","lookup","destroy_block","create_component","mount_component","customElement","m","new_on_destroy","map","destroy_component","detaching","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","skip_bound","ready","rest","hydrate","nodes","Array","childNodes","children","l","intro","SvelteComponent","$destroy","this","$on","type","index","splice","$set","$$props","obj","$$set","keys","subscriber_queue","stores","config","initialValue","browser","localStorage","updateStorage","key2","setItem","JSON","stringify","subscribers","new_value","run_queue","subscriber","invalidate","internal","set2","json","getItem","parse","handleStorage","newValue","updater","writable","title","bgPath","services","iconUrl","iconW","iconH","id","t_value","div","h1","time","interval","setInterval","$$invalidate","clearInterval","hours","getHours","minutes","getMinutes","seconds","getSeconds","img","img_src_value","dispatchFinalizeEvent","el","items","dispatchEvent","CustomEvent","detail","dispatchConsiderEvent","DRAGGED_ENTERED_EVENT_NAME","DRAGGED_LEFT_EVENT_NAME","DRAGGED_OVER_INDEX_EVENT_NAME","DRAGGED_LEFT_DOCUMENT_EVENT_NAME","DRAGGED_LEFT_TYPES","dispatchDraggedElementEnteredContainer","containerEl","indexObj","draggedEl","dispatchDraggedElementLeftContainerForAnother","theOtherDz","dispatchDraggedElementIsOverIndex","TRIGGERS","SOURCES","SHADOW_ITEM_MARKER_PROPERTY_NAME","SHADOW_ELEMENT_ATTRIBUTE_NAME","SHADOW_PLACEHOLDER_ITEM_ID","ITEM_ID_KEY","activeDndZoneCount","incrementActiveDropZoneCount","decrementActiveDropZoneCount","isOnServer","getBoundingRectNoTransforms","ta","rect","tx","sx","sy","dx","dy","startsWith","slice","transformOrigin","parseFloat","y","w","offsetWidth","h","offsetHeight","getAbsoluteRectNoTransforms","scrollY","scrollX","getAbsoluteRect","findCenter","isPointInsideRect","point","findCenterOfElement","isCenterOfAInsideB","elA","elB","calcDistanceBetweenCenters","centerOfA","centerOfB","pointA","pointB","Math","sqrt","pow","dzToShadowIndexToRect","resetIndexesCache","resetIndexesCacheForDz","dz","findWouldBeIndex","floatingAboveEl","collectionBelowEl","isProximityBased","shadowElIndex","findIndex","child","cacheShadowRect","cachedShadowRect","indexOfMin","minDistanceSoFar","Number","MAX_VALUE","distance","makeScroller","scrollingInfo","resetScrolling","directionObj","undefined","stepPx","scrollContainer","scrollBy","calcScrollStepPx","distancePx","scrollIfNeeded","pointer","elementToScroll","distances","min","documentElement","clientWidth","calcInnerDistancesBetweenPointAndSidesOfElement","isAlreadyScrolling","scrollingVertically","scrollingHorizontally","scrollHeight","clientHeight","scrollWidth","toString","object","getDepth","_getDepth","countSoFar","parentElement","observe","dropZones","intervalMs","lastDropZoneFound","lastIndexFound","lastCentrePositionOfDragged","lastIsDraggedInADropZone","dropZonesFromDeepToShallow","sort","dz1","dz2","andNow","currentCenterOfDragged","scrolled","abs","setTimeout","isElementOffDocument","dispatchDraggedLeftDocument","isDraggedInADropZone","dispatchDraggedElementLeftContainerForNone","mousePosition","updateMousePosition","e","touches","clientX","clientY","trs","property","morphDraggedElementToBeLike","copyFromEl","currentMouseX","currentMouseY","transformDraggedElement","newRect","draggedElRect","widthChange","heightChange","relativeDistanceOfMousePointerFromDraggedSides","copyStylesFromTo","copyToEl","computedStyle","s","getPropertyValue","getPropertyPriority","styleDraggable","draggableEl","dragDisabled","draggable","ondragstart","userSelect","WebkitUserSelect","cursor","hideElement","dragTarget","display","zIndex","styleActiveDropZones","getStyles","getClasses","styles","classList","styleInactiveDropZones","contains","remove","DEFAULT_DROP_TARGET_STYLE","outline","originalDragTarget","draggedElData","draggedElType","originDropZone","originIndex","shadowElData","shadowElDropZone","dragStartMousePosition","currentMousePosition","unlockOriginDzMinDimensions","isWorkingOnPreviousDrag","finalizingPreviousDrag","isDraggedOutsideOfAnyDz","scheduledForRemovalAfterDrop","typeToDropZones","dzToConfig","elToMouseDownListener","WeakMap","unregisterDropZone","dropZoneEl","watchDraggedElement","handleDraggedEntered","handleDraggedLeft","handleDraggedIsOverIndex","handleDrop","observationIntervalMs","max","dropAnimationDurationMs","unWatchDraggedElement","clearTimeout","findShadowElementIdx","item","dropFromOthersDisabled","currentTarget","newOriginZoneItems","trigger","source","shadowPlaceHolderIdx","findShadowPlaceHolderIdx","shadowElIdx","shadowItem","originZoneItems","handleMouseMove","preventDefault","moveDraggedElementToWasDroppedState","dropTargetStyle","dropTargetClasses","shadowElRect","newTransform","transition","animateDraggedToFinalPosition","shadowEl","visibility","destroy","cleanupPostDrop","dndzone","initialized","flipDurationMs","morphDisabled","centreDraggedOnCursor","elToIdx","removeMaybeListeners","handleMouseMoveMaybeDragStart","handleFalseAlarm","currentIdx","rootNode","originDropZoneRoot","body","placeHolderElData","keepOriginalElementInDom","focus","originalElement","positionCenterOnXY","cloned","cloneNode","values","elIsSelect","tagName","selects","querySelectorAll","select","clonedSelects","optionEl","querySelector","svelteNodeClone","elTopPx","elLeftPx","center","margin","boxSizing","createDraggedElementFrom","originalMinHeight","minHeight","originalMinWidth","minWidth","preventShrinking","passive","capture","handleDragStart","handleMouseDown","isContentEditable","button","stopPropagation","configure","newType","getConfigProp","propName","objA","objB","keyA","hasOwnProperty","call","areObjectsShallowEqual","arrA","arrB","areArraysShallowEqualSameOrder","idx","newOptions","destroyDz","INSTRUCTION_IDs","DND_ZONE_ACTIVE","DND_ZONE_DRAG_DISABLED","ID_TO_INSTRUCTION","alertsDiv","initAriaOnBrowser","opacity","prepend","entries","txt","innerHTML","instructionToHiddenDiv","alertToScreenReader","alertText","draggedItemType","focusedDz","focusedItem","focusedItemId","isDragging","focusedDzLabel","focusedItemLabel","allDragTargets","WeakSet","elToKeyDownListeners","elToFocusListeners","dzToHandles","registerDropZone","readyState","globalKeyDownHandler","globalClickHandler","getElementById","activeElement","handleZoneFocus","newlyFocusedDz","originItems","originItem","find","originIdx","itemToMove","targetItems","autoAriaDisabled","unshift","triggerAllDzsUpdate","dispatchConsider","blur","zoneTabIndex","swap","arr","j","handleKeyDown","disabled","focusedItemIdx","tabIndex","setCurrentFocusedItem","dropTargets","msg","handleClick","handles","validateOptions","pointerZone","pointerDndZone","keyboardZone","keyboardDndZone","console","warn","itemWithMissingId","isArray","isNaN","cubicOut","flip","ox","oy","u","t0_value","div1","div0","t0","stop_animation","get_key","section","action_result","old_blocks","dynamic","list","create_each_block","get_context","n","old_indexes","new_blocks","new_lookup","deltas","child_ctx","will_move","did_move","first","new_block","old_block","new_key","old_key","onDrop","newItems","h2","h30","input0","span0","hr","h31","small","input1","span1","h32","buttons_changes","configTemp","$config","variable","initial","each_value","each_blocks","iterations","levels","updates","to_null_out","accounted_for","$$scope","spread_props","style___bgPath","div2","settingsMode"],"mappings":"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"}